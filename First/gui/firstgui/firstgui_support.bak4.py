#! /usr/bin/env python
#
# Support module generated by PAGE version 4.10
# In conjunction with Tcl version 8.6
#    Jan 29, 2018 05:02:43 PM
#    Feb 02, 2018 04:53:00 AM
#    Feb 02, 2018 05:00:31 AM
#    Feb 03, 2018 04:45:02 AM
#    Feb 03, 2018 04:47:15 AM
#    Feb 03, 2018 07:04:46 AM
#    Feb 03, 2018 07:05:03 AM
#    Feb 03, 2018 07:19:22 AM
#    Feb 03, 2018 08:32:39 AM
#    Feb 03, 2018 08:41:53 AM
#    Feb 03, 2018 10:23:33 AM
#    Feb 03, 2018 10:28:37 AM

from dbMySql import c, f

try:
    from Tkinter import *
except ImportError:
    from tkinter import *
    from tkinter import filedialog
    from tkinter import messagebox

try:
    import ttk
    py3 = 0
except ImportError:
    import tkinter.ttk as ttk
    py3 = 1

def set_Tk_var():
    # global setmaindisplays
    global stv22
    stv22 = StringVar()
    global che44
    che44 = StringVar()
    global che45
    che45 = StringVar()
    global spinbox
    spinbox = StringVar()
    global che66
    che66 = StringVar()
    global entry1txt
    entry1txt = StringVar()
    global che67
    che67 = StringVar()

def entryValue(self):
    return self.w.value

def button_press(event):

    widget = event.widget

    element = widget.identify(event.x, event.y)

    if "close" in element:
        index = widget.index("@%d,%d" % (event.x, event.y))
        widget.state(['pressed'])
        widget._active = index

def button_release(event):

    widget = event.widget

    if not widget.instate(['pressed']):
            return

    element = widget.identify(event.x, event.y)

    try:
        index = widget.index("@%d,%d" % (event.x, event.y))
    except TclError:
        pass

    if "close" in element and widget._active == index:
        widget.forget(index)
        widget.event_generate("<<NotebookTabClosed>>")

    widget.state(["!pressed"])
    widget._active = None

def setmaindisplays():
    sys.stderr = RedirectText(w.ErrorDisplay)
    sys.stdout = RedirectText(w.OutputDisplay)

def dbclosebtn(p1):
    c.dbclose(p1)

def dbconnectbtn(p1):
    c.dbconnect(p1)

def enterbtn(p1):
    eval(entry1txt.get())
    sys.stdin.flush()

# def fetchall():
class fetchall(object):
    def __init__(self, master):
        top = self.top = Toplevel(master)
        self.l = Label(top, text="Hello World")
        self.l.pack()
        self.e = Entry(top)
        self.e.pack()
        self.b = Button(top, text='Ok', command=self.cleanup)
        self.b.pack()

    def cleanup(self):
        self.value = self.e.get()
        self.top.destroy()


    # t = f()
    # print("Which table would you like to fetch:...")
    # w.Entry1.delete(0, "end")
    # fet = entry1txt.get()
    # fetch = fet.strip().lower()
    # if fetch == 'fetch':
    #     print("Ok you wish to fetch {}".format(fetch))
    # treeViews.TreeView1(w.Scrolledtreeview1)

class MainPopWindow(object):
    def __init__(self,top):
        self.master=top
        self.b=Button(top,text="click me!",command=self.popup)
        self.b.pack()
        self.b2=Button(top,text="print value",command=lambda: sys.stdout.write(self.entryValue()+'\n'))
        self.b2.pack()
        self.b3 = Button(top, text='Ok', command=self.cleanup)
        self.b3.pack()


    def popup(self):
        self.w=fetchall(self.master)
        self.b["state"] = "disabled"
        self.master.wait_window(self.w.top)
        self.b["state"] = "normal"

    def entryValue(self):
        return self.w.value

    def cleanup(self):
        self.top.destroy()



def process_command(text):
    ''' Given a string, returns a string in response. '''
    text = text.strip().lower()
    if text == 'dbconnect':
        t = c()
        t.dbconnect()
    elif text == 'dbclose':
        t = c()
        t.dbclose()
    elif text in {'currentdb', 'database', 'current database'} :
        t = f()
        t.currentDB()
    elif text == 'fetch':
        print('ok')
        g = MainPopWindow(root)
    elif text in {'quit', 'exit'}:
        # clear the input field
        try:
            print('Attempting to quit')
        except AttributeError:
            pass
    else:
        print('Unknown Command')

class RedirectText1(object):
    def __init__(self, text_widget):
        self.text_space = text_widget

    def process_callback(self, *args):
        ''' Callback that's called when the user presses enter or
            clicks the button. '''

        # figure out what the response to the input should be
        self.response = process_command(entry1txt.get())

        if self.response is None:
            # print('Please type a vaild command')
            w.Entry1.delete(0, "end")
            return

class RedirectText(object):
    def __init__(self, text_widget):
        self.text_space = text_widget

    def write(self, string):
        self.text_space.config(state=NORMAL)
        self.text_space.insert("end", string)
        self.text_space.see("end")
        self.text_space.config(state=DISABLED)

def open_file():
    """
    Open a file, read it line-by-line and print out each line to
    the text control widget
    """
    options = {}
    options['defaultextension'] = '.txt'
    options['filetypes'] = [('all files', '.*'), ('text files', '.txt')]
    options['initialdir'] = '/home'
    options['parent'] = root
    options['title'] = "Open a file"

    with filedialog.askopenfile(mode='r', **options) as f_handle:
        for line in f_handle:
            print(line)

def mouse_over(event):

    widget = event.widget
    element = widget.identify(event.x, event.y)

    if "close" in element:
        widget.state(['alternate'])

    else:
        widget.state(['!alternate'])

def init(top, gui, *args, **kwargs):
    global w, top_level, root
    w = gui
    # processCommand.set_Tk_var()
    top_level = top
    # processCommand.init(root, top)
    setmaindisplays()
    root = top

def destroy_window():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None

if __name__ == '__main__':
    from gui.firstgui import firstgui

    firstgui.vp_start_gui()





































