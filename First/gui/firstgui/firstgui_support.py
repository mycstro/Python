#! /usr/bin/env python
#
# Support module generated by PAGE version 4.10
# In conjunction with Tcl version 8.6
#    Feb 04, 2018 06:50:22 AM
#    Feb 04, 2018 12:56:20 PM
#    Feb 05, 2018 05:16:24 PM

from dbMySql import c, f
from mysql.connector.cursor import MySQLCursor

try:
    from Tkinter import *
except ImportError:
    from tkinter import *
    import tkinter.ttk
    from tkinter import filedialog
    from tkinter import messagebox

try:
    import ttk
    py3 = 0
except ImportError:
    import tkinter.ttk as ttk
    py3 = 1

def set_Tk_var():
    # global setmaindisplays
    global stv22
    stv22 = StringVar()
    global che44
    che44 = StringVar()
    global che45
    che45 = StringVar()
    global spinbox
    spinbox = StringVar()
    global che66
    che66 = StringVar()
    global entry1txt
    entry1txt = StringVar()
    global che67
    che67 = StringVar()

def entryValue(self):
    return self.w.value

def button_press(event):

    widget = event.widget

    element = widget.identify(event.x, event.y)

    if "close" in element:
        index = widget.index("@%d,%d" % (event.x, event.y))
        widget.state(['pressed'])
        widget._active = index

def button_release(event):

    widget = event.widget

    if not widget.instate(['pressed']):
            return

    element = widget.identify(event.x, event.y)

    try:
        index = widget.index("@%d,%d" % (event.x, event.y))
    except TclError:
        pass

    if "close" in element and widget._active == index:
        widget.forget(index)
        widget.event_generate("<<NotebookTabClosed>>")

    widget.state(["!pressed"])
    widget._active = None

def setmaindisplays():
    sys.stderr = RedirectText(w.ErrorDisplay)
    sys.stdout = RedirectText(w.OutputDisplay)

def dbclosebtn(p1):
    c.dbclose(p1)

def dbconnectbtn(p1):
    c.dbconnect(p1)

def enterbtn(p1):
    eval(entry1txt.get())
    sys.stdin.flush()

class Fetch_One():
    def __init__(self, master, tree_widget):
        top=self.top=Toplevel(master)
        self.l=Label(top,text="Hello World")
        self.l.pack()
        self.text_space = tree_widget

    def fetch1(self):
        _c = c()
        _conn1 = _c.dbconnect()
        cursor = MySQLCursor(_conn1)
        cursor.execute("Select * From books")
        row = cursor.fetchone()
        for row in range(1, 10):
            row = cursor.fetchone()
            # print(row)
            bid = row[0]
            bna = row[1]
            bis = row[2]
            # wp = w.PNotebook1_t0
            # wpt = wp.TPanedwindow1_p1
            Fetch_One.tree.insert("", "end", text=bid, values=(bna, bis))

class FetchPopWindow():
    def __init__(self,master):
        top = self.top = Toplevel(master)
        self.master=master
        self.popwin()

    def popwin(self):
        self.f1=Label(self.master,text="Which table would you like to see?")
        self.f1.pack()
        self.f2 = Entry(self.master)
        self.f2.configure(takefocus="True")
        self.f2.pack()
        self.f2.bind('<Return>',lambda e:self.getalltable(self.f2.get()))
        # self.f2=Button(top,text="Accept Value",command=lambda: sys.stdout.write(self.entryValue()+'\n'))
        self.f3 =Button(self.master,text='OK',command=lambda: self.getalltable(self.f2.get()))
        self.f3.pack()
        self.f4 = Button(self.master, text='Cancel', command=self.cleanup)
        self.f4.pack()

        self.tree = tkinter.ttk.Treeview(self.master, columns=('Col1', 'Col2'))
        self.tree.heading("#0", text='#', anchor='w')
        self.tree.heading("#1", text="Col1")
        self.tree.heading("#2", text="Col2")
        self.tree.column("#0", width=50)
        self.tree.column("#1", width=200)
        self.tree.column("#2", width=200)
        self.tree.column("#0", anchor="w")

    def fetch1(self):
        _c = c()
        _conn1 = _c.dbconnect()
        cursor = MySQLCursor(_conn1)
        cursor.execute("Select * From books")
        row = cursor.fetchone()
        for row in range(1, 10):
            row = cursor.fetchone()
            # print(row)
            bid = row[0]
            bna = row[1]
            bis = row[2]
            # wp = w.PNotebook1_t0
            # wpt = wp.TPanedwindow1_p1
            self.tree.insert("", "end", text=bid, values=(bna, bis))

    def getalltable(self, table):
        if table in {'books', 'users'}:
            if table == 'books':
                Fetch_One()
                # self.cleanup()
                print("You wish to see the books table.")
            elif table == 'users':
                # print("You wish to see the users table")
                fete = f()
                row = fete.query_with_fetchall("SELECT * FROM users")
                self.cleanup()
        elif table in {'quit', 'exit'}:
            self.cleanup()
            print("Fetch has quited")
        elif table is not None:
            self.sel = str(table)
            print(self.sel)
        elif table is None:
            print("Please type a table name")
        else:
            print("Unknown Table")

    def cleanup(self):
        self.top.destroy()

def process_command(text):
    ''' Given a string, returns a string in response. '''
    text = text.strip().lower()
    if text == 'dbconnect':
        t = c()
        t.dbconnect()
    elif text == 'dbclose':
        t = c()
        t.dbclose()
    elif text in {'currentdb', 'database', 'current database', 'database name'} :
        t = f()
        t.currentDB()
    elif text in {'fetch', 'fetch one', 'one', 'fetch many', 'many', 'fetch all', 'all'}:
        # print('ok')
        g = FetchPopWindow(root)
    elif text in {'quit', 'exit'}:
        # clear the input field
        try:
            print('Attempting to quit')
        except AttributeError:
            pass
    else:
        print('Unknown Command')

class RedirectText1(object):
    def __init__(self, text_widget):
        self.text_space = text_widget

    def process_callback(self, *args):
        ''' Callback that's called when the user presses enter or
            clicks the button. '''

        # figure out what the response to the input should be
        self.response = process_command(entry1txt.get())

        if self.response is None:
            # print('Please type a vaild command')
            w.Entry1.delete(0, "end")
            return

class RedirectText(object):
    def __init__(self, text_widget):
        self.text_space = text_widget

    def write(self, string):
        self.text_space.config(state=NORMAL)
        self.text_space.insert("end", string)
        self.text_space.see("end")
        self.text_space.config(state=DISABLED)

def open_file():
    """
    Open a file, read it line-by-line and print out each line to
    the text control widget
    """
    options = {}
    options['defaultextension'] = '.txt'
    options['filetypes'] = [('all files', '.*'), ('text files', '.txt')]
    options['initialdir'] = '/home'
    options['parent'] = root
    options['title'] = "Open a file"

    with filedialog.askopenfile(mode='r', **options) as f_handle:
        for line in f_handle:
            print(line)

def mouse_over(event):

    widget = event.widget
    element = widget.identify(event.x, event.y)

    if "close" in element:
        widget.state(['alternate'])

    else:
        widget.state(['!alternate'])

def init(top, gui, *args, **kwargs):
    global w, top_level, root
    w = gui
    # processCommand.set_Tk_var()
    top_level = top
    # processCommand.init(root, top)
    setmaindisplays()
    root = top

def destroy_window():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None

if __name__ == '__main__':
    from gui.firstgui import firstgui

    firstgui.vp_start_gui()














































